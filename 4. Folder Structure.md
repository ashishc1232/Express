
# 1. Folder Structure (WHY this structure)

```txt
express-app/
‚îÇ
‚îú‚îÄ‚îÄ server.js          --> app start point (engine start)
‚îú‚îÄ‚îÄ package.json       --> project info + dependencies
‚îÇ
‚îú‚îÄ‚îÄ routes/            --> only URL handling
‚îÇ   ‚îî‚îÄ‚îÄ userRoutes.js
‚îÇ
‚îú‚îÄ‚îÄ controllers/       --> actual logic (brain)
‚îÇ   ‚îî‚îÄ‚îÄ userController.js
‚îÇ
‚îú‚îÄ‚îÄ models/            --> data / DB logic
‚îÇ   ‚îî‚îÄ‚îÄ userModel.js
‚îÇ
‚îú‚îÄ‚îÄ middleware/        --> request checks (security, validation)
‚îÇ   ‚îî‚îÄ‚îÄ authMiddleware.js
‚îÇ
‚îî‚îÄ‚îÄ config/            --> DB config (future use)
    ‚îî‚îÄ‚îÄ db.js
```

---

# 2. server.js (ENTRY POINT ‚Äì MOST IMPORTANT)

```js
// import express library
// express is a framework built on top of Node.js
const express = require('express');

// create express application
// app is the main object which controls everything
const app = express();

// import user routes
// this file contains all /api/users routes
const userRoutes = require('./routes/userRoutes');

// middleware to parse incoming JSON request body
// without this, req.body will be undefined
app.use(express.json());

// tell express:
// whenever URL starts with /api/users
// forward the request to userRoutes
app.use('/api/users', userRoutes);

// define port number
const PORT = 3000;

// start server and listen on port
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### WHY server.js exists?

* Starts server
* Loads routes
* Applies global middleware
* Entry point of app

---

# 3. routes/userRoutes.js (ONLY URL + METHOD)

```js
// import express
const express = require('express');

// create router object
// router works like mini express app
const router = express.Router();

// import controller functions
// controllers contain actual logic
const {
  getUsers,
  getUserById,
  createUser
} = require('../controllers/userController');

// import middleware
// middleware runs BEFORE controller
const authMiddleware = require('../middleware/authMiddleware');

// GET /api/users
// authMiddleware runs first
// if allowed, then getUsers runs
router.get('/', authMiddleware, getUsers);

// GET /api/users/:id
// :id is URL parameter
router.get('/:id', getUserById);

// POST /api/users
router.post('/', createUser);

// export router so server.js can use it
module.exports = router;
```

### WHY routes exist?

* Keep URLs separate
* Clean code
* Easy to manage large apps

---

# 4. controllers/userController.js (BUSINESS LOGIC)

```js
// import user model
// model handles data
const User = require('../models/userModel');

// GET /api/users
const getUsers = (req, res) => {

  // call model function to get users
  const users = User.getAllUsers();

  // send response with status code
  res.status(200).json(users);
};

// GET /api/users/:id
const getUserById = (req, res) => {

  // req.params.id comes from URL
  const user = User.getUserById(req.params.id);

  // if user not found
  if (!user) {
    return res.status(404).json({ message: 'User not found' });
  }

  // if user found
  res.status(200).json(user);
};

// POST /api/users
const createUser = (req, res) => {

  // destructuring data from request body
  const { name, email } = req.body;

  // call model to create user
  const newUser = User.createUser(name, email);

  // return created user
  res.status(201).json(newUser);
};

// export functions so routes can use them
module.exports = {
  getUsers,
  getUserById,
  createUser
};
```

### WHY controllers exist?

* Hold main logic
* Keep routes clean
* Easier debugging & testing

---

# 5. models/userModel.js (DATA LAYER)

```js
// fake database (array)
// later this will be replaced by real DB
let users = [
  { id: 1, name: 'Amit', email: 'amit@gmail.com' },
  { id: 2, name: 'Ravi', email: 'ravi@gmail.com' }
];

// get all users
const getAllUsers = () => {
  return users;
};

// find user by id
const getUserById = (id) => {

  // Number(id) because URL param is string
  return users.find(user => user.id === Number(id));
};

// create new user
const createUser = (name, email) => {

  // create user object
  const newUser = {
    id: users.length + 1,
    name,
    email
  };

  // add to users array
  users.push(newUser);

  // return new user
  return newUser;
};

// export model functions
module.exports = {
  getAllUsers,
  getUserById,
  createUser
};
```

### WHY models exist?

* Handle DB/data logic
* Controller doesn‚Äôt care HOW data is stored
* DB can change without breaking controller

---

# 6. middleware/authMiddleware.js (REQUEST CHECKER)

```js
// middleware function
// runs before controller
const authMiddleware = (req, res, next) => {

  // read authorization header
  const token = req.headers.authorization;

  // if token not present
  if (!token) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  // if token exists
  // allow request to continue
  next();
};

// export middleware
module.exports = authMiddleware;
```

### WHY middleware exists?

* Authentication
* Validation
* Logging
* Security

---

# 7. COMPLETE FLOW (REMEMBER THIS)

```
Client (Postman / Browser)
 ‚Üì
server.js (entry)
 ‚Üì
routes (URL decision)
 ‚Üì
middleware (check permission)
 ‚Üì
controller (logic)
 ‚Üì
model (data)
 ‚Üì
response sent back
```

---

# 8. ONE-LINE REMEMBER RULE

```
server.js  ‚Üí start app
routes     ‚Üí where to go
middleware ‚Üí allowed or not
controller ‚Üí what to do
model      ‚Üí data handling
```

---

# 9. HOW YOU SHOULD PRACTICE (IMPORTANT)

1. Change response text and test
2. Add console.log in middleware, controller
3. Remove middleware and see difference
4. Add new route yourself (`PUT / DELETE`)




Just tell me what you want üëç
